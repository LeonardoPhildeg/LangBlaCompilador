options{  static = false;}PARSER_BEGIN(langBla)package parser;import java.io.*;public class langBla {  final static String Version = "B+- Compiler - Version 1.0 - 2018";  boolean Menosshort = false; // saida resumida = falso  //Define o metodo main da classe langBla  public static void main(String args []) throws ParseException {	    String filename = "/home/wellington/Desktop/teste.txt";// nome do arquivo a ser analisado	    langBla parser; //AL/AS		int i;		boolean ms = false;			System.out.println(Version);			//parametros passados para o compilador		for (i=0; i < args.length - 1; i++) {			if (args[i].toLowerCase().equals("-short" )) {				ms = true;			} else {			  System.out.println("Usa is: java langBla [-short] inputfile");			  System.exit(0);			}	  	}		  	if(args[i].equals("-")) { //entrada padrao	  		System.out.println("Reading from standard input . . .");	  		parser = new langBla(System.in);	 	} else { 	 		filename = args[args.length-1];	 		System.out.println("Reading from file " + filename + " . . .");	 		try {	 		  	parser = new langBla(new java.io.FileInputStream(filename));	 		} catch (java.io.FileNotFoundException ex) {	 		  	System.out.println("File " + filename + " not found");	 		  	return;	 		}		}	 	  		  	parser.Menosshort = ms;	  	try {     		parser.program(); // caso de sucesso de parser    		System.out.println("Sucesso!");  		} catch (ParseException e) {  			System.out.println(e);  		} catch (TokenMgrError e) {  	  		System.out.println(e);  		}	  	//verifica se houve erro lexico	  	if(parser.token_source.foundLexError() != 0) {	  		System.out.println( parser.token_source.foundLexError() + "Lexical Errors found");	 	} else { 	 	  	System.out.println("Program successfully analized.");		}	}	static public String im(int x) { // metodo auxiliar		int k;		String s;		s = tokenImage[x];		k = s.lastIndexOf("\"");		try {		  	s = s.substring(1,k);		} catch (StringIndexOutOfBoundsException ex) {		}		return s;	}}PARSER_END(langBla)TOKEN_MGR_DECLS :
{
int countLexError = 0;

public int foundLexError() {
  	return countLexError;
}
}
SKIP :{  " "| "\r"| "\t"| "\n"| "\f"}SKIP :{  "/*": multilinecomment //ao encontrar um /* o AL vai para o estado multilinecomment, ignorando tudo que venha até o fim do estado| "//": singlelinecomment}<multilinecomment> SKIP:{  "*/": DEFAULT //ao encontrar um */ acha o fim do estado multilinecomment e volta para o estado padrão do AL| <~[]>}<singlelinecomment> SKIP:{  <["\n","\r"]>: DEFAULT| <~[]>}TOKEN : /* Palavras reservadas */{< BREAK: "break" >| < CLASS: "class" >| < CONSTRUCTIOR: "constructor" >| < ELSE: "else" >| < EXTENDS: "extends" >| < FOR: "for" >| < IF: "if" >| < INT: "int" >| < NEW: "new" >| < PRINT: "print" >| < READ: "read" >| < RETURN: "return" >| < STRING: "string" >| < SUPER: "super" >}TOKEN : /* Operadores */{  < ASSIGN: "=" >| < GT: ">" >| < LT: "<" >| < EQ: "==" >| < LE: "<=" >| < GE: ">=" >| < NEQ: "!=" >| < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" > //STAR no livro| < DIVIDE : "/" > //SLASH no livro| < REM: "%" >| < NOT: "not" >| < AND: "and" >| < OR: "or" >| < XOR: "xor" >}TOKEN : /* simbolos especiais */{  < LPAREN: ")" >| < RPAREN: "(" >| < LBRACE: "{" >| < RBRACE: "}" >| < LBRACKET: "[" >| < RBRACKET: "]" >| < SEMICOLON: ";" >| < COMMA: "," >| < DOT: "." > }TOKEN : /* Constantes */{//números decimais, octais, hexadecimais, binários< int_constant: (  (["0"-"9"] (["0"-"9"])* ) |  (["0"-"7"] (["0"-"7"])* ["o", "O"] ) |  (["0"-"9"] (["0"-"7","A"-"F","a"-"f"])* ["h", "H"] ) |  (["0"-"1"] (["0"-"1"])* ["b", "B"])) > |// reconhecimento de ponto flutuante, float< float_constant: (  (["0"-"9"] (["0"-"9"])* ["."] ["0"-"9"] (["0"-"9"])*)) > |//reconhecimento de boolean< boolean_constant: "true" | "false" > //reconhecimento de string| < string_constant: "\""( ~["\"","\n","\r"])* "\"" >//reconhecimento de char| < char_constant: "\'"( ~["\"","\n","\r"])* "\'" >// reconhecimento de nulo| < null_constant: "null" > }/* Identificadores */TOKEN:{  < IDENT: < LETTER > (< LETTER >|< DIGIT >)* >| < CONSTANT : (< DIGIT >)+ >| < #LETTER:["A"-"Z","a"-"z"] >| < #DIGIT:["0"-"9"] >}/* Tratamento de erros lexicos */SPECIAL_TOKEN:{<INVALID_LEXICAL:(~ ["a"-"z", "A"-"Z", "0"-"9", "\"", "(", ")", "[", "]", "{", "}", ";", ",", ".", "=", ">", "<", "!", "+", "-","*", "/", "%", " ", "\t", "\n", "\r", "\f"])+ >	{	  System.err.print("Line " + input_stream.getEndLine() + " - Invalid string found: " + image);	  countLexError++;	}|	<INVALID_CONST:	"\"" (~ ["\n", "\r", "\""])* ["\n", "\r"] >		{	  System.err.print("Line " + input_stream.getEndLine() + " - String constant has a \\n: " + image);	  countLexError++;	}}    void program() :{}{  (    <PLUS> { System.out.println("Reconheceu PLUS"); }   | <MINUS> { System.out.println("Reconheceu MINUS"); }   | <MULTIPLY> { System.out.println("Reconheceu MULTIPLY"); }   | <DIVIDE> { System.out.println("Reconheceu DIVIDE"); }    | <int_constant> { System.out.println("Reconheceu INTEIRO"); }    | <float_constant> { System.out.println("Reconheceu PONTO FLUTUANTE"); }    | <boolean_constant> { System.out.println("Reconheceu EXPRESSAO BOOLEANA"); }    | <null_constant> { System.out.println("Reconheceu NULO"); }    | <char_constant> { System.out.println("Reconheceu CHAR"); }    | <string_constant> { System.out.println("Reconheceu STRING"); }    | <NOT> { System.out.println("Reconheceu NOT"); }    | <AND> { System.out.println("Reconheceu AND"); }    | <OR> { System.out.println("Reconheceu OR"); }    | <XOR> { System.out.println("Reconheceu XOR"); }    )*}
